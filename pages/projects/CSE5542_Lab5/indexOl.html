<html><head>
<title>Realtime rendering - Lab 5 - Skylar Wurster </title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>

<!--  ************** Fragment Shader ************* --> 

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
    precision mediump int;
    
    varying vec4 vEyePosition;
    varying vec4 vColor; 
    varying vec3 vNorm;
    varying mat4 vNormMatrix;
    varying vec4 temp;
    varying vec4 light_eye_position;
    varying vec3 ambient;
    varying vec3 diffuse;
    varying vec3 specular;
    varying float shininess;
    varying highp vec2 FTexCoord;

    uniform int use_texture;
    uniform int use_normalMap;
    uniform int use_reflectionMapping;
    uniform int use_lighting;

    uniform sampler2D myTexture;
    uniform sampler2D normalMap;
    uniform samplerCube myCubeMap;
    uniform mat4 v2wMatrix;
    uniform vec2 texture_scale;
    uniform vec2 texture_offset;

    
    
    void main(void) {    

        vec3 texColor;
        vec3 a = ambient;
        vec3 d = diffuse;
        vec3 s = specular;

        vec3 light_vector_from_vertex = normalize(vec3(light_eye_position - vEyePosition));
        vec3 eye_vector_to_vertex = normalize(-vec3(vEyePosition));
        vec3 fragmentNormal = vNorm;
        highp vec2 newTexPos = vec2((FTexCoord[0]+texture_offset[0])*texture_scale[0], (FTexCoord[1]+texture_offset[1])*texture_scale[1]);

        if(use_normalMap == 1){
            fragmentNormal = normalize(vNorm + vec3(texture2D(normalMap, newTexPos)));
        }
        vec3 light_reflect_off_vertex = normalize(vec3(reflect(-light_vector_from_vertex, fragmentNormal)));

        float diffPower = (max(dot(fragmentNormal, light_vector_from_vertex), 0.0));
        float specPower = pow((max(dot(light_reflect_off_vertex, eye_vector_to_vertex), 0.0)), shininess);

        if(dot(fragmentNormal, light_vector_from_vertex) <= 0.0){
            s = vec3(0.0, 0.0, 0.0);
        } 
        if(use_reflectionMapping == 1){
            vec3 reflectionVector = normalize(reflect(-eye_vector_to_vertex, fragmentNormal));
            reflectionVector = vec3(v2wMatrix*vec4(reflectionVector,0.0));
            texColor = vec3(textureCube(myCubeMap, reflectionVector));
            d = texColor;
            a = vec3(0, 0, 0);
            s = vec3(0, 0, 0);
            if(use_lighting == 1){
                d = texColor * diffPower;
                a = ambient * texColor;
            }
        }
        else if(use_texture == 1){
            
            texColor = vec3(texture2D(myTexture, newTexPos));
            d = texColor;
            a = vec3(0, 0, 0);
            s = vec3(0, 0, 0);
            if(use_lighting == 1){
                d = texColor * diffPower;
                a = ambient*texColor;
            }
        }              
        else{
            a = ambient;
            d = diffuse * diffPower;
            s = specular*specPower;
            
            if(use_lighting != 1){
                a = vec3(0, 0, 0);
                s = vec3(0, 0, 0);
                d = diffuse;
            }
        }
        gl_FragColor = vec4(a + d + s, 1.0);  

    
    }
    </script>
    
    <!--  ************** Vertex Shader ************* --> 
    <script id="shader-vs" type="x-shader/x-vertex">
    precision mediump float;
    precision mediump int; 

    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec4 aVertexColor;
    attribute vec2 aVertexTexCoord;

    uniform mat4 uMMatrix;
    uniform mat4 uVMatrix;
    uniform mat4 uPMatrix;
    uniform mat4 uNMatrix;
    
    uniform vec3 material_ambient;
    uniform vec3 material_diffuse;
    uniform vec3 material_specular;
    uniform float material_shininess;
    
    uniform vec4 light_position;
    uniform vec3 light_ambient;
    uniform vec3 light_diffuse;
    uniform vec3 light_specular;
    
    varying vec4 vEyePosition;
    varying vec4 vColor;
    varying vec3 vNorm;
    varying mat4 vNormMatrix;
    varying vec4 temp;
    varying vec4 light_eye_position;
    varying vec3 ambient;
    varying vec3 diffuse;
    varying vec3 specular;
    varying float shininess;
    varying highp vec2 FTexCoord;
    
    void main(void) {
        vEyePosition = uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
        temp = aVertexColor;
        
        vNorm = normalize(aVertexNormal);
        vNorm = normalize(vec3(uNMatrix * vec4(aVertexNormal, 0.0)));
    
        light_eye_position = uVMatrix * light_position;
    
        specular = light_specular * material_specular;
        ambient = light_ambient * material_ambient;
        diffuse = light_diffuse * material_diffuse;
        shininess = material_shininess;
    
        gl_Position = uPMatrix * vEyePosition;
        gl_PointSize = 10.0;

        FTexCoord = aVertexTexCoord;
    }
</script>


<script type="text/javascript" src="shaderSetup.js"></script>
<script type="text/javascript" src="Lab5.js"></script>

<link rel="stylesheet" href="tree.css">

</head>


<body id="lab5-body" onload="webGLStart();">
    <canvas id="lab5-canvas" width="500" height="500" style="border:none;"></canvas>
    <br>
    <div>
    <ul id="heirarchy"></ul>
    <br>
    <form>
    <p>Position</p>
    X:<input type="text" name="xPos" id="xPos" onChange="transformGO()"> Y:<input type="text" onChange="transformGO()" name="yPos" id="yPos"> Z:<input type="text" onChange="transformGO()"  name="zPos" id="zPos">   
    <p>Rotation</p>
    X:<input type="text" name="xRot" id="xRot" onChange="transformGO()"> Y:<input type="text" onChange="transformGO()" name="yRot" id="yRot"> Z:<input type="text" onChange="transformGO()" name="zRot" id="zRot">
    <p>Scale</p>
    X:<input type="text" name="xScale" id="xScale" onChange="transformGO()"> Y:<input type="text" onChange="transformGO()" name="yScale" id="yScale"> Z:<input type="text" onChange="transformGO()" name="zScale" id="zScale">
    <p>Texture offset</p>
    X:<input type="text" name="texOffsetX" id="texOffsetX" onChange="transformGO()"> Y:<input type="text" name="texOffsetY" id="texOffsetY" onChange="transformGO()">
    <p>Texture scale</p>
    X:<input type="text" name="texScaleX" id="texScaleX" onChange="transformGO()"> Y:<input type="text" name="texScaleY" id="texScaleY" onChange="transformGO()">
    </form>
    <button id="renderPoints" width ="50" height="20" onClick="renderPoints()">Render points</button>
    <button id="renderLines" width ="50" height="20" onClick="renderLines()">Render lines</button>
    <button id="renderTriangles" width ="50" height="20" onClick="renderTriangles()">Render triangles</button>
    <br>
    <button id="toggleLighting" width ="50" height="20" onClick="toggleLighting()">Toggle lighting</button>
    <button id="toggleTexture" width ="50" height="20" onClick="toggleTexture()">Toggle texture</button>
    <button id="toggleNormalMap" width ="50" height="20" onClick="toggleNormalMap()">Toggle normal map</button>
    <button id="toggleCubemap" width ="50" height="20" onClick="toggleCubemap()">Toggle cubemap</button>
    </div>
    <br>
    <b><u>Instructions:</u></b>
    <br>
    Use mouse to look around. 
    <br>Press left control to turn off mouse looking
    <br>Press WSAD for forward, backward, left, right
    <br>Press EQ for up, down
    <br>Select any gameObject in the scene by clicking it in the heirarchy. You may adjust any values for position, rotation, scale, texture offset, or texture scale. 
    <br>You can also render just points, lines, or triangles by clicking the buttons, or toggle lighting, textures, normal maps, or cubemaps.

</body>
</html>